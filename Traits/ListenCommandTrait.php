<?phpnamespace DefenderService\DamMicroService\Traits;use DefenderService\DamMicroService\LogService\DamLog;trait ListenCommandTrait{    private  $PidFile;    //pid文件    private  $PidIds;     //进程ID    private  $counter;    private  $ForkNumber;    private  $childrenIds = [];    /**     * @description 守护进程     * @author changsheng.gu@vcg.com     * @param     * @return void     */    private function demonize()    {        if (!defined('WNOHANG')){            throw new \Exception('Must install pcntl extension first');        }        $pid_t = pcntl_fork();//        if($pid_t == -1){            pcntl_get_last_error();            exit(1);        }elseif ($pid_t>0){            exit(0);  //父进程退出        }        if(posix_setsid() == -1)        {            die('Could not detach');        }        chdir('/');        umask(0);        self::writePid();    }    /**     * @description doFork     * @author changsheng.gu@vcg.com     * @param  $count integer  $number integer     * @return void     */    private function doFork(&$count,&$number)    {        for($count=0;$count<$number;$count++)        {            $cid =pcntl_fork();            if($cid == -1)            {                pcntl_get_last_error();                exit(1);            }elseif ($cid==0){                $this->writePid();                break;            }else{                array_push($this->childrenIds,$cid);            }        }    }    /**     * @description writePid     * @author changsheng.gu@vcg.com     * @param     * @return void     */    private function writePid()    {        $fp = fopen($this->PidFile, 'a');        if(!$fp) throw new \Exception('Try to open the pid file failed');        fwrite($fp, posix_getpid().PHP_EOL);        fclose($fp);    }    /**     * @description 获取进程pid     * @author changsheng.gu@vcg.com     * @param     * @return array     */    private function getPidIds()    {        if (!file_exists($this->PidFile))  return [];        $pidFile    = file_get_contents($this->PidFile);        $pids       = array_filter(explode("\n",$pidFile));        $findPids  = [];        foreach ($pids as $val)        {            if(posix_kill(intval($val), SIG_DFL)) $findPids [] = $val;        }        if (empty($findPids)) {            unlink($this->PidFile);            return [];        } else {            return $findPids;        }    }    /**     * @description     * @author changsheng.gu@vcg.com     * @param  $count integer  $number integer     * @return void     */    private function childExec($count,$number)    {        if($count<$number) $this->listen();    }    /**     * @description 监控子进程     * @author changsheng.gu@vcg.com     * @param     * @return void     */    private function parentExec()  //主进程维护子进程    {        if($this->counter == $this->ForkNumber)        {            while(count($this->childrenIds) > 0)            {                foreach($this->childrenIds as $key => $pid)                {                    $res = pcntl_waitpid($pid, $status, WNOHANG);                    // If the process has already exited                    if($res == -1 || $res > 0){                        unset($this->childrenIds[$key]);                        if(!pcntl_wifexited($status))                        {                            sleep(2);                            #$stopPid [] = $pid;                            $stopSig = pcntl_wtermsig($status);                            if($stopSig!=SIGKILL)                            {                                DamLog::channel('queue_process_manager')->info("检测到子进程:$pid 异常中断. 中断信号为:$stopSig");                                printf("检测到子进程:%d 异常中断. 中断信号为:\%d\n",$pid,$stopSig);                                $count  = 0;                                $number = 1;                                printf("子进程:%d .重启中\n",$pid);                                DamLog::channel('queue_process_manager')->info("子进程:$pid .重启中");                                $this->doFork($count,$number);//重新拉起新的进程                                #printf("子进程:%d .重启成功\n",$pid); //打印会出现两次,因为新拉起的子进程会同样执行该printf输出                                self::childExec($count,$number);                            }                        }                    }                }                sleep(1);            }            printf("所有子进程已回收完毕\n");        }    }    /**     * @description process     * @author changsheng.gu@vcg.com     * @param  string     * @return void     */    protected function process($param)    {        if($param == 'start'){            $this->start();        }elseif ($param == 'stop'){            $this->stop();        }elseif($param =='status'){            $this->status();        }    }    /**     * @description start     * @author changsheng.gu@vcg.com     * @param     * @return void     */    public function start()    {        if (!empty($this->getPidIds()))        {            $this->printInfo('The queue already Running');        } else {            self::demonize();            $this->printInfo('Start Success');            self::doFork($this->counter,$this->ForkNumber);            self::parentExec();            self::childExec($this->counter,$this->ForkNumber);        }    }    /**     * @description run     * @author changsheng.gu@vcg.com     * @param     * @return void     */    protected function stop()    {        $pid = $this->getPidIds();        if (!empty($pid)) {            foreach ($pid as $val){                posix_kill(intval($val), SIGTERM);            }            unlink($this->PidFile);            $this->printInfo('Stop success');        } else            $this->printInfo('Stop Failed. Process Not Running');    }    /**     * @description run     * @author changsheng.gu@vcg.com     * @param  string     * @return void     */    protected function status()    {        if (!empty($this->getPidIds())){            $this->printInfo('Is Running');        } else            $this->printInfo('Not Running');    }    /**     * @description run     * @author changsheng.gu@vcg.com     * @param  string     * @return void     */    private function printInfo($message)    {        echo $message.PHP_EOL;    }}