<?phpnamespace DefenderService\DamMicroService\Queue;use DefenderService\DamMicroService\Traits\ListenCommandTrait;use Illuminate\Queue\Events\JobFailed;use Illuminate\Queue\Events\JobProcessed;use Mockery\Exception;use Monolog\Logger;use Monolog\Handler\StreamHandler;use DefenderService\DamMicroService\LogService\DamLog;class QueueManager{    static $workerTimes = 0;    static $maxTimes;    static $damQueue = false;    use ListenCommandTrait;    /**     * Execute the job.     * create by changsheng.gu@vcg.com     * @return void     */    public function MaxWorkTimes($event)    {        if(!self::$damQueue) return;        self::$maxTimes  = config('damQueueManager.workerMaxTimes')??500;        if($event instanceof JobProcessed ||$event instanceof JobFailed)        {            echo 7;            pcntl_sigprocmask(SIG_BLOCK, array(SIGUSR1)); //阻塞信号集            $this->register_signal(SIGUSR1);            $oldset = array();            pcntl_sigprocmask(SIG_UNBLOCK, array(SIGUSR1),$oldset); //解阻塞塞信号集*/            if(self::$workerTimes >=self::$maxTimes)            {                posix_kill(posix_getpid(), SIGTERM);            }        }        else{            pcntl_sigprocmask(SIG_BLOCK, array(SIGUSR1)); //阻塞信号集            self::$workerTimes++;        }    }    /**     * get instance     * create by changsheng.gu@vcg.com     * @return object     */    public static function instance()    {        return new self();    }}