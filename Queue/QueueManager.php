<?phpnamespace DefenderService\DamMicroService\Queue;use DefenderService\DamMicroService\Traits\ListenCommandTrait;use Illuminate\Queue\Events\JobFailed;use Illuminate\Queue\Events\JobProcessed;use Mockery\Exception;use Monolog\Logger;use Monolog\Handler\StreamHandler;use DefenderService\DamMicroService\LogService\DamLog;use Symfony\Component\Debug\Exception\FatalErrorException;class QueueManager{    static $workerTimes = 0;    static $maxTimes;    static $damQueue = false;    static $connectTryTimes = 0;    use ListenCommandTrait;    /**     * Execute the job.     * create by changsheng.gu@vcg.com     * @return void     */    public function MaxWorkTimes($event,$failedLog=false)    {        if(!self::$damQueue) return;        self::$maxTimes  = config('damQueueManager.workerMaxTimes')??100;//单个worker最大任务处理数量        if($event instanceof JobProcessed ||$event instanceof JobFailed) {            $rawBody = $event->job->getRawBody();            $data = json_decode($rawBody,true);            if(isset($data['data']['command'])){                $command = unserialize($data['data']['command']);                if($event instanceof JobFailed){                    $id = $failedLog->log(                        $event->connectionName, $event->job->getQueue(),                        $event->job->getRawBody(), $event->exception                    );                    if (method_exists($command, 'damJobFailed')){                        $command->damJobFailed($id,$command,$rawBody);                    }                }else{                    if (method_exists($command, 'damJobFailed')){                        $command->damJobSuccess($command,$rawBody);                    }                }            }            $oldset = array();            pcntl_sigprocmask(SIG_UNBLOCK, array(SIGUSR1),$oldset); //解阻塞塞信号集*/            if(self::$workerTimes >=self::$maxTimes) {                posix_kill(posix_getpid(), SIGUSR2);            }        }        else{            register_shutdown_function(function()use($event,$failedLog) {                $this->queueShutdown($event,$failedLog);            });            pcntl_sigprocmask(SIG_BLOCK, array(SIGUSR1)); //阻塞信号集            self::$workerTimes++;        }        self::$connectTryTimes = 0;    }    /**     * get instance     * create by changsheng.gu@vcg.com     * @return object     */    public static function instance()    {        return new self();    }    /**     * queueShutDown     * create by changsheng.gu@vcg.com     * @return void     */    protected function queueShutdown($event,$failedLog){        if (!is_null($error = error_get_last()) && $this->checkFotalError($error['type'])){            if($failedLog){                $failedLog->log(                    $event->connectionName, $event->job->getQueue(),                    $event->job->getRawBody(),new FatalErrorException($error['message'],                        $error['type'], 0, $error['file'], $error['line'])                );            }        }    }    /**     * checkFatalError     * create by changsheng.gu@vcg.com     * @return boolean     */    protected function checkFatalError($type)    {        $errorCodes = [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE];        if (defined('FATAL_ERROR')) {            $errorCodes[] = FATAL_ERROR;        }        return in_array($type, $errorCodes);    }}